<div id="blocker">
  <div id="instructions">
    <span style="font-size:40px">Click to play</span>
    <br />
    (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
  </div>
</div>
<script>
var camera, scene, renderer, controls;

var objects = [];

var raycaster;

var blocker = document.getElementById('blocker');
var instructions = document.getElementById('instructions');

// http://www.html5rocks.com/en/tutorials/pointerlock/intro/

var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document ||
  'webkitPointerLockElement' in document;

if (havePointerLock) {

  var element = document.body;

  var pointerlockchange = function (event) {

    if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement ===
      element) {

      controlsEnabled = true;
      controls.enabled = true;

      blocker.style.display = 'none';

    } else {

      controls.enabled = false;

      blocker.style.display = 'block';

      instructions.style.display = '';

    }

  };

  var pointerlockerror = function (event) {

    instructions.style.display = '';

  };

  // Hook pointer lock state change events
  document.addEventListener('pointerlockchange', pointerlockchange, false);
  document.addEventListener('mozpointerlockchange', pointerlockchange, false);
  document.addEventListener('webkitpointerlockchange', pointerlockchange, false);

  document.addEventListener('pointerlockerror', pointerlockerror, false);
  document.addEventListener('mozpointerlockerror', pointerlockerror, false);
  document.addEventListener('webkitpointerlockerror', pointerlockerror, false);

  instructions.addEventListener('click', function (event) {

    instructions.style.display = 'none';

    // Ask the browser to lock the pointer
    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
    element.requestPointerLock();

  }, false);

} else {

  instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

}

var controlsEnabled = false;

var moveForward = false;
var moveBackward = false;
var moveLeft = false;
var moveRight = false;
var canJump = false;

var prevTime = performance.now();
var velocity = new THREE.Vector3();
var direction = new THREE.Vector3();
var vertex = new THREE.Vector3();
var color = new THREE.Color();

init();
animate();

function init() {
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.translateY(16);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);
  scene.fog = new THREE.Fog(0xffffff, 0, 750);

  var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
  light.position.set(0.5, 1, 0.75);
  scene.add(light);

  controls = new THREE.PointerLockControls(camera);
  scene.add(controls.getObject());

  var onKeyDown = function (event) {

    switch (event.keyCode) {

      case 38: // up
      case 87: // w
        moveForward = true;
        break;

      case 37: // left
      case 65: // a
        moveLeft = true;
        break;

      case 40: // down
      case 83: // s
        moveBackward = true;
        break;

      case 39: // right
      case 68: // d
        moveRight = true;
        break;

      case 32: // space
        if (canJump === true) velocity.y += 350;
        canJump = false;
        break;

    }

  };

  var onKeyUp = function (event) {

    switch (event.keyCode) {

      case 38: // up
      case 87: // w
        moveForward = false;
        break;

      case 37: // left
      case 65: // a
        moveLeft = false;
        break;

      case 40: // down
      case 83: // s
        moveBackward = false;
        break;

      case 39: // right
      case 68: // d
        moveRight = false;
        break;

    }

  };

  document.addEventListener('keydown', onKeyDown, false);
  document.addEventListener('keyup', onKeyUp, false);

  raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);

  // floor

  geometry = new THREE.PlaneGeometry(800, 800, 0, 0);
  geometry.rotateX(-Math.PI / 2);
  floorTexture = new THREE.TextureLoader().load(
    'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTABCiDPjncx4Na0KlSx45XNMxLroHa06tAibR6GTb9ARirjMZQ');
  floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
  floorTexture.repeat.set(20, 20);
  material = new THREE.MeshBasicMaterial({
      map: floorTexture
    }),
    mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  // var geometry = new THREE.SphereGeometry(40, 40, 40, 0, Math.PI *2, 0, 0.5*Math.PI);
  // // var link = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRayHLURKisL2wZawPCnx-J-ahowfDwQ1MNjsPR2MtQVYn1QNfn'
  // var link = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTor4EAHb7F7hxsro75fqTODuZ8tMU06X_DmsjAddVTs-blsYiT'
  // // var link = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSeB2k2p2tiNfag6-_1L_P-sU3m9VxL6HG0vMow4JkP72hvC9dD'
  // sphereTexture = new THREE.TextureLoader().load(link );
  // sphereTexture.wrapS = sphereTexture.wrapT = THREE.sphereTexture;
  // material = new THREE.MeshBasicMaterial({map: sphereTexture}),
  // ceiling = new THREE.Mesh(geometry, material);
  // ceiling.material.side = THREE.BackSide;

  // scene.add(ceiling);
  var textures_array = []
    <% @test_info.each do |coin| %>
       path = '<%=coin%>'
       floorTexture1 = new THREE.TextureLoader().load(path);
       floorTexture1.wrapS = floorTexture1.wrapT = THREE.RepeatWrapping;
       textureMesh =  new THREE.MeshBasicMaterial({
         map: floorTexture1
       })
      textures_array.push(textureMesh);
    <% end %>

  var objectLoader = new THREE.ObjectLoader();
  objectLoader.load("../assets/model_plan/coinmuseum.json", function (obj) {


    cube = new THREE.CubeGeometry(3, 3, 0.2)

    var coins_array = [];

    var k = 0
    for (let i = -1; i < 85; i += 5) {
      if (i < 36 || i > 46) {
        cube1 = new THREE.Mesh(cube ,textures_array[k]); k+=1
        cube1.position.set(i, 2.5, 4.8);
        obj.add(cube1);
        cube2 =  new THREE.Mesh(cube ,textures_array[k]); k+=1
        cube2.position.set(i, 2.5, -35.6);
        obj.add(cube2);
        coins_array.push(cube1);
        coins_array.push(cube2);
      }
    }

    for (let i = 0; i < 84; i += 5) {
      if (i < 34 || i > 47.5) {
        cube1 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube1.position.set(i, 2.5, 3.6);
        obj.add(cube1);
        cube2 =  new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube2.position.set(i, 2.5, -34.3);
        obj.add(cube2);
        coins_array.push(cube1);
        coins_array.push(cube2);
      }
    }


    for (let i = 2.5; i > -36.5; i -= 5) {
      cube3 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
      cube3.position.set(-3.4, 2.5, i);
      cube3.rotateY(-Math.PI / 2);
      obj.add(cube3);
      cube33 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
      cube33.position.set(-2, 2.5, i);
      cube33.rotateY(-Math.PI / 2);
      obj.add(cube33);
      cube4 =  new THREE.Mesh(cube ,textures_array[k]); k+=1;
      cube4.position.set(85.7, 2.5, i);
      cube4.rotateY(-Math.PI / 2);
      obj.add(cube4);
      cube5 =  new THREE.Mesh(cube ,textures_array[k]); k+=1;
      cube5.position.set(84.3, 2.5, i);
      cube5.rotateY(-Math.PI / 2);
      obj.add(cube5)

      if (i > -25 ) {
        cube1 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube1.position.set(36, 2.5, i);
        cube1.rotateY(-Math.PI / 2);
        obj.add(cube1);
        cube11 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube11.position.set(35, 2.5, i);
        cube11.rotateY(-Math.PI / 2);
        obj.add(cube11);
        cube2 =  new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube2.position.set(46.1, 2.5, i);
        cube2.rotateY(-Math.PI / 2);
        obj.add(cube2);
        cube22 =  new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube22.position.set(47.4, 2.5, i);
        cube22.rotateY(-Math.PI / 2);
        obj.add(cube22);


        coins_array.push(cube1);
        coins_array.push(cube11);
        coins_array.push(cube2);
        coins_array.push(cube22);
      }

      if (i < -5) {
        cube6 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube6.position.set(65.1, 2.5, i);
        cube6.rotateY(-Math.PI / 2);
        obj.add(cube6);
        cube66 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube66.position.set(66.6, 2.5, i);
        cube66.rotateY(-Math.PI / 2);
        obj.add(cube66);
        coins_array.push(cube6);
        coins_array.push(cube66);

      }
      coins_array.push(cube3);
      coins_array.push(cube33);
      coins_array.push(cube4);
      coins_array.push(cube5);
    }

    cube7 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube7.position.set(79.5, 2.5, -15.8);
    obj.add(cube7);
    cube77 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube77.position.set(79.5, 2.5, -14.6);
    obj.add(cube77);
    coins_array.push(cube7);
    coins_array.push(cube77);

    cube8 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube8.position.set(11.5, 2.5, -15.8);
    obj.add(cube8);
    cube88 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube88.position.set(11.5, 2.5, -14.6);
    obj.add(cube88);
    coins_array.push(cube8);
    coins_array.push(cube88);

    cube9 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube9.position.set(21.5, 2.5, -15.8);
    obj.add(cube9);
    cube99 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube99.position.set(21.5, 2.5, -14.6);
    obj.add(cube99);
    coins_array.push(cube9);
    coins_array.push(cube99);

    cube10 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube10.position.set(15.5, 2.5, -20.8);
    cube10.rotateY(-Math.PI / 2);
    obj.add(cube10);
    cube101 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube101.position.set(15.5, 2.5, -9.6);
    cube101.rotateY(-Math.PI / 2);
    obj.add(cube101);
    coins_array.push(cube101);
    coins_array.push(cube10);

    cube102 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube102.position.set(17, 2.5, -20.8);
    cube102.rotateY(-Math.PI / 2);
    obj.add(cube102);
    cube103 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube103.position.set(17, 2.5, -9.6);
    cube103.rotateY(-Math.PI / 2);
    obj.add(cube103);
    coins_array.push(cube103);
    coins_array.push(cube102);
    console.log(coins_array.length);
    scene.add(obj);
    obj.position.set(-80, 0, 0);
    obj.scale.set(3, 3, 3);


  });

var objectLoader1 = new THREE.ObjectLoader();
  objectLoader1.load("../assets/model_plan/coinmuseum.json", function (obj) {
      cube = new THREE.CubeGeometry(3, 3, 0.2)

      var coins_array = [];

    var k = 0
    for (let i = -1; i < 85; i += 5) {
      if (i < 36 || i > 46) {
        cube1 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube1.position.set(i, 2.5, 4.8);
        obj.add(cube1);
        cube2 =  new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube2.position.set(i, 2.5, -35.6);
        obj.add(cube2);
        coins_array.push(cube1);
        coins_array.push(cube2);
      }
    }

    for (let i = 0; i < 84; i += 5) {
      if (i < 34 || i > 47.5) {
        cube1 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube1.position.set(i, 2.5, 3.6);
        obj.add(cube1);
        cube2 =  new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube2.position.set(i, 2.5, -34.3);
        obj.add(cube2);
        coins_array.push(cube1);
        coins_array.push(cube2);
      }
    }


    for (let i = 2.5; i > -36.5; i -= 5) {
      cube3 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
      cube3.position.set(-3.4, 2.5, i);
      cube3.rotateY(-Math.PI / 2);
      obj.add(cube3);
      cube33 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
      cube33.position.set(-2, 2.5, i);
      cube33.rotateY(-Math.PI / 2);
      obj.add(cube33);
      cube4 =  new THREE.Mesh(cube ,textures_array[k]); k+=1;
      cube4.position.set(85.7, 2.5, i);
      cube4.rotateY(-Math.PI / 2);
      obj.add(cube4);
      cube5 =  new THREE.Mesh(cube ,textures_array[k]); k+=1;
      cube5.position.set(84.3, 2.5, i);
      cube5.rotateY(-Math.PI / 2);
      obj.add(cube5)

      if (i > -25 ) {
        cube1 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube1.position.set(36, 2.5, i);
        cube1.rotateY(-Math.PI / 2);
        obj.add(cube1);
        cube11 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube11.position.set(35, 2.5, i);
        cube11.rotateY(-Math.PI / 2);
        obj.add(cube11);
        cube2 =  new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube2.position.set(46.1, 2.5, i);
        cube2.rotateY(-Math.PI / 2);
        obj.add(cube2);
        cube22 =  new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube22.position.set(47.4, 2.5, i);
        cube22.rotateY(-Math.PI / 2);
        obj.add(cube22);


        coins_array.push(cube1);
        coins_array.push(cube11);
        coins_array.push(cube2);
        coins_array.push(cube22);
      }

      if (i < -5) {
        cube6 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube6.position.set(65.1, 2.5, i);
        cube6.rotateY(-Math.PI / 2);
        obj.add(cube6);
        cube66 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
        cube66.position.set(66.6, 2.5, i);
        cube66.rotateY(-Math.PI / 2);
        obj.add(cube66);
        coins_array.push(cube6);
        coins_array.push(cube66);

      }
      coins_array.push(cube3);
      coins_array.push(cube33);
      coins_array.push(cube4);
      coins_array.push(cube5);
    }

    cube7 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube7.position.set(79.5, 2.5, -15.8);
    obj.add(cube7);
    cube77 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube77.position.set(79.5, 2.5, -14.6);
    obj.add(cube77);
    coins_array.push(cube7);
    coins_array.push(cube77);

    cube8 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube8.position.set(11.5, 2.5, -15.8);
    obj.add(cube8);
    cube88 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube88.position.set(11.5, 2.5, -14.6);
    obj.add(cube88);
    coins_array.push(cube8);
    coins_array.push(cube88);

    cube9 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube9.position.set(21.5, 2.5, -15.8);
    obj.add(cube9);
    cube99 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube99.position.set(21.5, 2.5, -14.6);
    obj.add(cube99);
    coins_array.push(cube9);
    coins_array.push(cube99);

    cube10 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube10.position.set(15.5, 2.5, -20.8);
    cube10.rotateY(-Math.PI / 2);
    obj.add(cube10);
    cube101 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube101.position.set(15.5, 2.5, -9.6);
    cube101.rotateY(-Math.PI / 2);
    obj.add(cube101);
    coins_array.push(cube101);
    coins_array.push(cube10);

    cube102 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube102.position.set(17, 2.5, -20.8);
    cube102.rotateY(-Math.PI / 2);
    obj.add(cube102);
    cube103 = new THREE.Mesh(cube ,textures_array[k]); k+=1;
    cube103.position.set(17, 2.5, -9.6);
    cube103.rotateY(-Math.PI / 2);
    obj.add(cube103);
    coins_array.push(cube103);
    coins_array.push(cube102);
    console.log(coins_array.length);
    scene.add(obj);
    obj.position.set(-350, 0, -150);
    obj.rotateY(-Math.PI / 2);
    obj.scale.set(3, 3, 3);
  });

























  renderer = new THREE.WebGLRenderer({
    antialias: true
  });

  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  //

  window.addEventListener('resize', onWindowResize, false);

}

function onWindowResize() {

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);

}

function animate() {

  requestAnimationFrame(animate);

  if (controlsEnabled === true) {

    raycaster.ray.origin.copy(controls.getObject().position);
    raycaster.ray.origin.y -= 10;

    var intersections = raycaster.intersectObjects(objects);

    var onObject = intersections.length > 0;

    var time = performance.now();
    var delta = (time - prevTime) / 1000;

    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;

    velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

    direction.z = Number(moveForward) - Number(moveBackward);
    direction.x = Number(moveLeft) - Number(moveRight);
    direction.normalize(); // this ensures consistent movements in all directions

    if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
    if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

    if (onObject === true) {

      velocity.y = Math.max(0, velocity.y);
      canJump = true;

    }

    controls.getObject().translateX(velocity.x * delta);
    controls.getObject().translateY(velocity.y * delta);
    controls.getObject().translateZ(velocity.z * delta);

    if (controls.getObject().position.y < 10) {

      velocity.y = 0;
      controls.getObject().position.y = 10;

      canJump = true;

    }

    if( controls.getObject().position.x > 210 ){
      velocity.x = 0;
      controls.getObject().position.x = 210;
    }else if( controls.getObject().position.x < -391 ){
      velocity.x = 0;
      controls.getObject().position.x = -391;
    }

    if( controls.getObject( ).position.z < -187 ){
      velocity.z = 0;
      controls.getObject( ).position.z = -187;
    }else if( controls.getObject( ).position.z > 157 ){
      velocity.z = 0;
      controls.getObject( ).position.z = 157;
    }
    prevTime = time;

  }

  renderer.render(scene, camera);

}




</script>
